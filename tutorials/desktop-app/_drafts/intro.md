---
layout: post
title: "[Desktop App] 1. Intro"
categories: [tutorials, desktop-app]
tags: [electron, react, webpack]
---

일렉트론을 활용한 데스크톱 앱의 튜토리얼입니다.
이 문서는 프로토타입이기에 장황한 설명없이 곧바로 본론부터 들어가겠습니다.

목적은 단순 리액트 사용 튜토리얼이 아니라 프로덕션 레벨까지의 노하우 공유입니다.
고로 기본 API사용부터 테스트, 배포까지 다뤄질 부분입니다.

## 선행 지식

- Node.js
- ES2015
- React
- HTML/CSS

## 요구사양

- 일렉트론, 리액트를 활용해 개발
- 앱은 macOS 기본 앱의 디자인을 그대로 사용
- 클라우드를 활용한 데이터 동기화를 위해 PouchDB 사용
- 테스트 커버리지 95% 이상, Acceptance tests까지 적용

## 사용되는 스택

### Electron

Github에서 만든 데스크톱 앱이 제작가능한 플랫폼이다.
크로미움을 개조해서 만들었으며 노드헬퍼가 내장되어있어 브라우저API와 노드 API가 공존하고 있다.

### Node.js

기본적으로 Node.js에서 할 수 있는건 일렉트론에서도 할 수 있다. 물론 개발에서 순수하게 Node.js가 많이 쓰이는 곳은 빌드나 테스트환경이고 본 튜토리얼에서 일렉트론 내에 Node.js의 API를 사용하는 부분은 설정파일을 파일로서 저장할 때 정도가 되겠다.

### Webpack

자바스크립트 번들러입니다. 일렉트론에서 CommonJS2(`require`, `module.exports`)를 지원함에도 불구하고 이것을 사용하는 이유는 일부 브라우저 라이브러리는 이미 window에 노출되어있거나 AMD(requirejs)를 사용하기 때문에 `require`를 사용할 수가 없습니다. 웹팩을 활용하면 이런 문제가 해결됩니다.
또한, Hot Module Replacement(이하 HMR)을 활용하여 페이지 리프레쉬없이 필요한 모듈만 리로드하는 기능을 제공하여 개발속도를 극도로 가속시켜줍니다.
본 튜토리얼에서는 Webpack2를 사용할 계획입니다. 2버젼부터는 ES2015의 `import`, `export`가 사용 가능하기에 `require`보다 `import`를 기본적으로 사용하고 `Node.js`에서 직접 불러오는 라이브러리를 돋보이게 하기 위해 `require`를 따로 사용할 생각입니다.

### Babel

자바스크립트를 위한 트랜스파일러이다. 본 튜토리얼에서는 JSX와 ES2015 그리고 스테이지4 프리셋을 사용할 것이다.

### React

페이스북에서 만든 뷰 라이브러리입니다. Javascript의 Object트리를 활용해 HTML엘러먼트를 간편하게 렌더할 수 있습니다.

### React Router

URL을 통해 React 앱의 스테이트를 관리해줍니다. 일반적인 MVC 관점에서 보면 컨트롤러에 가깝습니다. `file://` 환경(로컬)에서 실행되는 일렉트론의 경우 네비게이션이 상당히 불편하지만 React Router는 해시 히스토리등 부가적인 옵션을 제공해 주기 때문에 간편히 해결 할 수 있습니다.

### Styled Components

HTML은 JSX를 활용하면 간단히 Javascript에 집어넣는게 가능하지만 CSS는 아직 그렇게 하지 못하였습니다. 이에 새롭게 나온게 `styled-components`로 Template Literal을 적극활용해 Javascript안에서도 CSS를 관리하기 쉽게되었습니다.

```jsx
import styled from 'styled-components'

const MyButton = styled`
 background-color: white;
 border: none;
 color: blue;
`

class MyApp {
  render () {
    return <div>
      <MyButton>Hi</MyButton>
    </div>
  }
}
```

### Redux

앱에 전역적인 스테이트 관리를 위해 필요합니다. 스토어, 리듀서, 매퍼, 액션등의 기능을 제공하고 있습니다.

- 스토어: 데이터를 관리하는 주체입니다.
- 액션: 스토어의 데이터를 수정하기 위한 명령입니다.
- 리듀서: 액션을 받아서 스토어의 스테이트를 어떻게 다룰지를 기술합니다.
- 매퍼: 엄밀하게 말하면 React Redux가 제공하는 기능입니다. 리듀서를 통해 나온 스테이트를 어떻게 컴포넌트에 넣을지를 결정합니다. 본 튜토리얼의 앱은 경량이기에 매퍼는 쓰지 않습니다.

흐름은 스토어가 스테이트를 가지고 리액트 컴포넌트에 제공해줍니다.
이 스테이트의 편집은 스토어(Store)에 명령(Action)을 내리고(Dispatch), 이를 Reducer가 처리하여 스토어의 새로운 스테이트를 준비해줍니다. 그리고 이 새로운 스테이트는 `mapStateToProps`(Mapper)를 통해 필요한 프롭만 추려서 컴포넌트에게 다시한번 제공합니다.

### Redux Thunk

Redux의 디스패치는 비동기로 이루어집니다.(스토어가 너무커서 느려질때 앱의 프리즈를 막기위해) 문제는 가끔 디스패치가 정확히 끝난 이후에 다음 명령을 내릴 수가 없다는 겁니다. 이에 Redux Thunk는 비동기가 API가 부르고 있는 실제 Dispatch를 노출시켜주어 정확히 Dispatch 다음에 코드를 실행 할 수 있게 해줍니다.

> Redux Saga가 비슷한 문제에대한 해결책을 제공하고있지만 저는 Redux Saga의 유용성에 회의가 듭니다. 바로 Redux Saga 역시 스테이트를 가진다는 건데, Redux가 다른 Flux 아키텍쳐보다 독보적으로 뛰어난 부분은 스테이트의 관리가 스토어 하나에서만 일어나고 이외 처리는 모두 리듀서와 맵퍼에서 행해지기 때문에 스테이트를 한 곳에만 두면 된다는건데 이미 우리는 React, Redux Store, React Router 3곳에 이미 스테이트를 관리하고 있습니다. 그리고 이 점 때문에 HMR을 이용이 껄끄로워집니다. 고로 본 튜토리얼에서는 Saga를 사용하지 않을 것입니다.

> 물론 튜토리얼 제작중에 요구 사항이 바뀌어서 Saga를 활용한 스테이트 관리가 필요하다 느껴질 경우 바뀔 수 있습니다. (어쩌면 동시에 쓸지도...)

---

### Redux Saga(Saga를 사용하게 될경우)

Redux의 디스패치는 비동기로 이루어집니다.(스토어가 너무커서 느려질때 앱의 프리즈를 막기위해) 이에대해 Redux Thunk를 사용함으로써 해결이 가능하지만, 같은 문제를 좀더 근본적으로 그리고 아름답게 해결할 수 있는 솔루션을 제공해줍니다.

### 장점

- 리액트에서는 순수하게 액션을 디스패치할 수 있다.
- 자주 발생하는 액션의 일괄처리가 가능하다.

### 단점

- 제네레이터를 사용하므로 난이도가 있다.
- 앱의 설계가 늘어난다.
- HMR에 대응하고 있지 않으므로 리로드가 필요하다.

---

### Jest

Facebook이 만든 테스트 러너입니다. 리액트 테스트를 위해 Virtual DOM을 기본적으로 제공합니다.
노드에서 작동하기 때문에 웹팩으로 컴파일된 코드를 테스트 할 수는 없지만, 웹팩의 환경을 따라하여 테스트를 하는 방법을 제시해줍니다.
모킹(Mocking) 기능도 강력하기에 Funtional 테스트는 문제없이 행할 수 있습니다.

> 웹팩으로 컴파일된 코드를 일렉트론에서 직접 테스트하기 위해선 `mocha-loader`를 써야합니다.

### PouchDB

브라우저와 Node.js에서 사용가능한 추상화된 데이터베이스 라이브러리 입니다.
CouchDB에 대응하기에 간편하게 오프라인 대책을 세울 수 있습니다.

동시에 다양한 어댑터를 제공하고 있으며 심지어 LevelDB까지 대응하고 있으므로, 실제 데이터베이스에 대해 매우 다양한 선택지를 가질 수 있습니다.

고로 IndexedDB를 사용하는 것도 가능하지만, LevelDB를 통해 MySQL이나 하나의 JSON같이 다양한 형식으로 데이터를 보존 할 수 있다.

### Sander

파일 읽고 쓰기를 좀더 간편하게 해줍니다. Node.js의 FS는 상당히 저레벨을 다루고 있기 때문에 그대로 쓰긴 불편합니다.
이에 `graceful-fs`를 사용하는 경우가 많은데 Sander는 이를 래핑해 Promise로 만들어줍니다.
